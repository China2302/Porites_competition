---
title: "Limma analysis"
author: "Natalia Andrade and Ira Cooke"
date: "07/08/2017"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(cache=TRUE)
options(width = 60)

library(knitr)
library(limma)
library(edgeR)
library(tidyverse)
library(ComplexHeatmap)
library(ggpubr)
library(circlize)
library(colorspace)
#install.packages('statmod')
```

```{r, include=FALSE}
#First we prepare the data.  
#This involves reading in a counts matrix from corset.  
#Then we extract the sample names from the columns and match those to conditions in an excel file that describes the experimental conditions for each sample.

counts <- read_tsv("hpc/corset/03-counts.txt") %>% 
  column_to_rownames(var="X1") %>% 
  as.matrix()

sample_data <- read_csv("raw_data/Samples_data.csv",trim_ws = TRUE)
colnames(sample_data) <- c("ID","Tank","HardCoral",'treat',"SoftCoralControl","PdvsL_Other")

sample_data_row_order <- match(colnames(counts),sample_data$ID)

counts2 <- data.frame(counts) %>% select(-PdLd) %>% as.matrix()

sample_data2 <- sample_data[match(colnames(counts2),sample_data$ID),] %>% 
  unite("HardCoralTrt",HardCoral,treat,remove = FALSE)
```


Initial data exploration with PCA revealed that PdLd is an extreme outlier.  We therefore excluded this sample from further analysis.  We also looked at library sizes and they are very similar to we use limma-trend rather than voom.

```{r, include=FALSE}
dge <- DGEList(counts=counts2)
dge <- calcNormFactors(dge)
design <- model.matrix(~treat,data = sample_data2)

keep <- rowSums(dge$counts[,c("PfC","PdC")]==0) != 1


dge_kept <- dge[keep,,keep.lib.sizes=FALSE]

cpm <- cpm(dge_kept,log=TRUE, prior.count=1)


corfit_trend <- duplicateCorrelation(cpm,design,block=sample_data2$HardCoral)

fit_trend <- lmFit(cpm, design, block = sample_data2$HardCoral, correlation = corfit_trend$consensus)

efit <- eBayes(fit_trend)

write_rds(efit,"cache/efit.rds")
```


```{r}
tt <- topTable(efit,number=Inf) %>% filter(adj.P.Val<0.1)

cpm[rownames(tt),] %>% coolmap()
```


```{r}
# MDS
mds_data <- plotMDS(cpm, plot = FALSE)

hm_col_groups <- list(blue = c("PdLb","PfLd","PfLa"), grey = c("PdC","PdLc","PfLe","PfLb","PfC"), red = c("PdLe","PdLa","PfLc"))

data.frame(x=mds_data$x,y=mds_data$y) %>% 
  rownames_to_column("ID") %>% 
  left_join(sample_data2) %>% 
  ggplot(aes(x=x,y=y)) + 
  geom_point(aes(shape=HardCoral,color=treat)) +
  geom_label_repel(aes(label=ID))

```


```{r}
# Heatmap
#

ct_genes_tidy <- cpm[rownames(tt),] %>%
  as.data.frame() %>%
  rownames_to_column("cluster_id")

ct_heatmap_data <- ct_genes_tidy %>%
  as.data.frame() %>%
  column_to_rownames("cluster_id")

ct_heatmap_data_relative <- sweep(ct_heatmap_data, MARGIN=1, STATS= rowMeans(ct_heatmap_data))

# Perform kmeans clustering and save the result in cache.
# There is some randomness in this so we save it for consistency
# This also allows transcripts within cluster to be extracted in later scripts
# #
# if ( file.exists("cache/row_km.rds")){
#   row_kmeans <- read_rds("cache/row_km.rds")
# } else {
#   row_kmeans <- kmeans(ct_heatmap_data_relative,centers = 5,nstart = 100)
#   write_rds(row_kmeans,"cache/row_km.rds")
# }

col_fun = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))
hm <- Heatmap(ct_heatmap_data_relative, 
                                      col = col_fun,
                                      column_km_repeats = 100,
                                      # row_km_repeats = 100,
                                      column_km = 3,
                                      row_split = row_kmeans$cluster,
                                      show_row_dend = FALSE,
                                      show_row_names = FALSE,
#                                      column_title_gp = gpar(fill = colgroup_colours, font = 1:3),
                                      heatmap_legend_param = list(title="LogFC", legend_width = unit(10,"cm")))

draw(hm)

```

